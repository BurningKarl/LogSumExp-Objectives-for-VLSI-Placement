% This file provides shorthands for writing grouped pairs of opening and closing brackets.
% The following types of brackets are supported with respective shorthand:
%  (       : R : round / parenthesis
%  [       : S : squared
%  \{      : C : curyl brace
%  \lceil  : U : ceiled (up)
%  \lfloor : D : floored (down)
%  \langle : A : angled\
%
% All brackets can be generated by the \bktX and \BktX macros where "X" is an appropriate shorthand.
% The lower-case version just adds brackets, the upper-case version additionally includes \left and \right.
%
% Examples:
%  \bktS{n}          : [n]
%  \BktC{x: 2x = 4y} : \left\{x: 2x = 4y\right\}
%
% For convenience there is also a version without shorthand defaulting to "R" (round).

% Defaults using the R-versions
\newcommand{\bkt}[1]{\bktR{#1}}
\newcommand{\Bkt}[1]{\BktR{#1}}

% R-versions
\newcommand{\bktR}[1]{\setWithBracketsBase{(}{#1}{)}}
\newcommand{\BktR}[1]{\SetWithBracketsBase{(}{#1}{)}}

% C-versions (If its a set, you might want to use \Set from the braket package)
\newcommand{\bktC}[1]{\setWithBrackets{\{}{#1}{\}}}
\newcommand{\BktC}[1]{\SetWithBrackets{\{}{#1}{\}}}

% S-versions
\newcommand{\bktS}[1]{\setWithBrackets{[}{#1}{]}}
\newcommand{\BktS}[1]{\SetWithBrackets{[}{#1}{]}}

% U-versions
\newcommand{\bktU}[1]{\setWithBrackets{\lceil}{#1}{\rceil}}
\newcommand{\BktU}[1]{\SetWithBrackets{\lceil}{#1}{\rceil}}

% D-versions
\newcommand{\bktD}[1]{\setWithBrackets{\lfloor}{#1}{\rfloor}}
\newcommand{\BktD}[1]{\SetWithBrackets{\lfloor}{#1}{\rfloor}}

% A-versions
\newcommand{\bktA}[1]{\setWithBrackets{\langle}{#1}{\rangle}}
\newcommand{\BktA}[1]{\SetWithBrackets{\langle}{#1}{\rangle}}

% Configuration
\newcommand{\innerBracketSpace}{2mu}

% Common implementation helpers used by other macros.
\newcommand{\setWithBracketsBase}[3]{#1{#2}#3}
\newcommand{\SetWithBracketsBase}[3]{\setWithBracketsBase{\left#1}{#2}{\right#3}}
\DeclareRobustCommand{\setWithBrackets}[3]{%
 \ifInnermost{\setWithBrackets}{#2}{%
  \setWithBracketsBase{#1}{\mspace{\innerBracketSpace}#2\mspace{\innerBracketSpace}}{#3}%
 }{%
  \setWithBracketsBase{#1}{#2}{#3}%
 }%
}
\DeclareRobustCommand{\SetWithBrackets}[3]{%
 \setWithBrackets{\left#1}{#2}{\right#3}%
}

\makeatletter

% Magic macro detecting innermost usage of a macro
% developed with Pietro.
\newcommand{\ifInnermost}[4]{%
  \let\ifInnermost@oldBraces#1%
  \gdef\ifInnermost@foundBraces{0}
  % https://tex.stackexchange.com/a/38340/26355
  \renewcommand{#1}[3]{%
    % Here you do need \gdef because of (probably) renewcommand,
    % otherwise the variable outside will not be updated
    \gdef\ifInnermost@foundBraces{1}%
    \renewcommand{#1}[3]{}%
  }%
  % This command stores into "0" (normally should be a macro) the box
  % with the content specified in the argument, but the arugment is
  % actually expanded, triggering the call to redefining foundBraces.
  % No output is produced.
  \sbox0{$#2$}%
  % Restore
  \let#1\ifInnermost@oldBraces%
  \ifnum\numexpr\ifInnermost@foundBraces\relax=0%
    #3%
  \else%
    #4%
  \fi%
}

\makeatother

